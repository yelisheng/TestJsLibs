<!doctype html><html><head><meta charset=UTF-8><title>docker - 分享会 - By 叶利生</title><link rel=stylesheet href=//cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=//cdn.staticfile.org/prism/1.15.0/themes/prism.min.css><link rel=stylesheet href=//cdn.staticfile.org/KaTeX/0.10.0-rc.1/katex.min.css><link rel=stylesheet href=//cdn.staticfile.org/KaTeX/0.5.1/katex.min.css><link href=./css/chunk-vendors.4e4765ff.css rel=stylesheet></head><body><div><article id=webslides><section slide class="slide bg-black-blue aligncenter" image="https://cn.bing.com/az/hprichbg/rb/RainierDawn_EN-AU3730494945_1920x1080.jpg .dark"><span class="background dark" style="background-image:url('https://cn.bing.com/az/hprichbg/rb/RainierDawn_EN-AU3730494945_1920x1080.jpg')"></span><div class=wrap wrap=true><h1 class="text-landing text-shadow">docker 分享会</h1><p class="text-intro animated fadeInUp delay-500">拓展应用部 叶利生</p><p><a href=https://hub.docker.com/ class="button ghost animated flipInX delay-1200" target=_blank><i class="fa fa-github"></i> Docker Hub</a></p></div></section><section slide class="slide size-40 aligncenter"><div class=wrap wrap=true><h2>docker</h2><hr><ul><li class="animated fadeInUp">docker基本概念</li><li class="animated fadeInUp delay-400">如何使用docker</li><li class="animated fadeInUp delay-800">ATM1项目的实践</li></ul></div></section><section slide class=slide :class=aligncenter><div class="wrap aligncenter" wrap=true><h2>docker是什么</h2><p class="lightSpeedIn animated slow"><code>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化，它将软件组件包装成一个完整的标准化单元，其中包含所有要运行的内容。 无论是代码，运行时环境，工具还是程序库。它保证软件能始终按预期那样运行。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。可以在给定的主机上同时运行多个容器。 它是轻量级的，可立即启动并使用较少的内存。 它是默认安全的，因为每个容器彼此隔离。</code></p></div></section><section slide class=slide :class=size-80><div class="wrap size-80" wrap=true><ul class=description><li><span class=text-label>镜像:</span> 镜像概念类似于虚拟机里的镜像，是一个只读的模板，一个独立的文件系统，包括运行容器所需的数据，可以用来创建新的容器(类)</li><li><span class=text-label>dockerFile:</span> 一个包含用于组合映像的命令的文本文档。可以使用在命令行中调用任何命令。 Docker通过读取Dockerfile中的指令自动生成映像。（编写类的实现代码）</li><li><span class=text-label>容器:</span> Docker容器是由Docker镜像创建的运行实例（创建类的实例）</li><li><span class=text-label>仓库:</span> 保存docker镜像仓库（git仓库）</li></ul></div></section><section slide class=slide :class=size-40><div class="wrap size-40" wrap=true><h2>docker的特点</h2><hr><ol class="text-cols build"><li class=bounce><strong>持续集成</strong></li><li class=swing><strong>版本控制</strong></li><li class=flash><strong>可移植性</strong></li><li class=pulse><strong>隔离性</strong></li><li class=shake><strong>安全性</strong></li></ol></div></section><section slide class="slide aligncenter"><div class=wrap wrap=true><h1 class=text-landing>二、如何使用docker</h1></div></section><section slide class="slide aligncenter"><div class=wrap wrap=true><p class=text-intro>MongoDB dockerfile</p><p><a href=https://github.com/docker-library/mongo/blob/757cedc3266e4c93d69b5c7d95cb68296d0f4d21/3.4/Dockerfile class="button ghost animated flipInX delay-1200" target=_blank>dockerfile</a></p><p class="animated fadeInUp"><strong>构建镜像 docker build -t yels/mongo .</strong></p></div></section><section slide class="slide aligncenter"><div class=wrap wrap=true><p class=text-intro>快速环境搭建环境，切入学习重点</p><p>部署MongoDB数据库运行环境的例子</p><p>docker run --rm -p=27017:27017 -v=$(pwd)/db/mongo/data:/data/db --name demo-mongo mongo</p><p>docker exec -it demo-mongo mongo admin</p></div></section><section slide class="slide aligncenter"><div class=wrap wrap=true><p class=text-intro>学习常用的CLI及使用GUI工具辅助操作</p><ul><li><p>镜像的指令</p></li><li><p>容器的指令</p></li><li><p>portainer</p></li></ul></div></section><section slide class=slide :class=size-130><div class="wrap size-130" wrap=true><p><code>docker run -d -p 9000:9000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer</code></p></div></section><section slide class=slide :class=aligncenter><div class="wrap aligncenter" wrap=true><h2>容器编排及部署</h2></div></section><section slide class=slide :class=size-60><div class="wrap size-60" wrap=true><h2>docker compose</h2><hr><p>使用 Docker 的时候，定义 Dockerfile 文件，然后使用 docker build、docker run 等命令操作容器。然而微服务架构的应用系统一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启停，那么效率之低，维护量之大可想而知 使用 Docker Compose 可以轻松、高效的管理容器，它是一个用于定义和运行多容器 Docker 的应用程序工具.</p></div></section><section slide class=slide :class=size-60><div class="wrap size-60" wrap=true><h2>docker machine</h2><hr><p>Docker 官方提供的一个工具，它可以帮助我们在远程的机器上安装 Docker，或者在虚拟机 host 上直接安装虚拟机并在虚拟机中安装 Docker。我们还可以通过 docker-machine 命令来管理这些虚拟机和 Docker.</p></div></section><section slide class=slide :class=size-60><div class="wrap size-60" wrap=true><h2>docker swarm</h2><hr><p>Swarm是Docker官方提供的一款集群管理工具，其主要作用是把若干台Docker主机抽象为一个整体，并且通过一个入口统一管理这些Docker主机上的各种Docker资源。Swarm和Kubernetes比较类似，但是更加轻，具有的功能也较kubernetes更少一些</p><div></div></div></section><section slide class=slide :class="size-80 aligncenter"><div class="wrap size-80 aligncenter" wrap=true><h1 class=text-landing>三、docker实践</h1><hr><p class="animated fadeInUp"><code>atm1脚本服务的docker应用</code></p></div></section><section slide class=slide :class="size-50 aligncenter"><div class="wrap size-50 aligncenter" wrap=true><h2>Thank you</h2></div></section></article></div><script src=//cdn.staticfile.org/echarts/4.1.0-release/echarts.min.js></script><script src=//cdn.staticfile.org/mermaid/8.0.0/mermaid.min.js></script><script>mermaid.startOnLoad = false;</script><script src=https://www.echartsjs.com/asset/theme/infographic.js></script><script>window.pluginsOptions = {"echarts":{"theme":"infographic"},"mermaid":{"theme":"forest"}}



document.addEventListener('DOMContentLoaded', () => {
    let isPrintMode = false;
    if(~location.search.indexOf('print-pdf')){
        isPrintMode = true;
        WebSlides.registerPlugin('scroll', function(){});
    }
    const ws = new WebSlides({
        loop: false
    })
    window.wsInstance = ws;
    if(isPrintMode){
        ws.slides.forEach(s=>s.show())
    }
}, false)</script><script src=./js/chunk-vendors.js></script><script src=./js/docker-part1.js></script></body></html>